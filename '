#ifndef AHRE_BROWSE_H__
#define AHRE_BROWSE_H__

#include "src/escape_codes.h"
#include "src/htmldoc.h"
#include "src/utils.h"
#include "src/generic.h"

#define T EscCode
#include <arl.h>

typedef struct { 
    HtmlDoc* htmldoc;
    BufOf(char) line;
    bool color;
    bool empty;
    bool pending_line;
    ArlOf(EscCode) esc_code_stack;
} BrowseCtx;

static inline HtmlDoc* browse_ctx_htmldoc(BrowseCtx ctx[static 1]) { return ctx->htmldoc; }
static inline TextBuf* browse_ctx_textbuf(BrowseCtx ctx[static 1]) {
    return htmldoc_textbuf(browse_ctx_htmldoc(ctx));
}

static inline bool browse_ctx_color(BrowseCtx ctx[static 1]) { return ctx->color; }

static inline bool* browse_ctx_empty(BrowseCtx ctx[static 1]) { return &ctx->empty; }
static inline bool* browse_ctx_pending_line(BrowseCtx ctx[static 1]) { return &ctx->pending_line; }
static inline bool browse_ctx_empty_get_set(BrowseCtx ctx[static 1], bool value) {
    bool was_empty = *browse_ctx_empty(ctx);
    *browse_ctx_empty(ctx) = value;
    return was_empty;
}

static inline bool browse_ctx_empty_get_set_and(BrowseCtx ctx[static 1], bool value) {
    bool was_empty = *browse_ctx_empty(ctx);
    *browse_ctx_empty(ctx) &= value;
    return was_empty;
}

static inline ArlOf(EscCode)* browse_ctx_esc_code_stack(BrowseCtx ctx[static 1]) {
    return &ctx->esc_code_stack;
}

static inline Err browse_ctx_esc_code_push(BrowseCtx ctx[static 1], EscCode code) {
    if (arlfn(EscCode, append)(browse_ctx_esc_code_stack(ctx), &code)) return Ok;
    return "error: arlfn append failure";
}

static inline Err browse_ctx_esc_code_pop(BrowseCtx ctx[static 1]) {
    return arlfn(EscCode, pop)(browse_ctx_esc_code_stack(ctx)) ? Ok : "error: empty stack";
}

static inline EscCode* browse_ctx_esc_code_stack_backp(BrowseCtx ctx[static 1]) {
    ArlOf(EscCode)* stack = browse_ctx_esc_code_stack(ctx);
    return arlfn(EscCode, back)(stack);
}

static inline BufOf(char)* browse_ctx_line(BrowseCtx ctx[static 1]) { return &ctx->line; }
static inline size_t browse_ctx_line_len(BrowseCtx ctx[static 1]) {
    return browse_ctx_line(ctx)->len;
}
static inline char* browse_ctx_line_items(BrowseCtx ctx[static 1]) { 
    return browse_ctx_line(ctx)->items;
}

static inline Err browse_ctx_line_append(BrowseCtx ctx[static 1], char* s, size_t len) { 
    return buffn(char, append)(browse_ctx_line(ctx), s, len)
        ? Ok
        : "error: failed to append to bufof (browse ctx line)";
}

#define browse_ctx_line_append_lit__(Ctx, Str) browse_ctx_line_append(Ctx, Str, sizeof(Str)-1)

static inline Err _append_empty_line_to_doc_(BrowseCtx ctx[static 1]) {
    ///TODO: append eol
    BufOf(char)* buf = &htmldoc_textbuf(browse_ctx_htmldoc(ctx))->buf;
    if (buffn(char, append)(buf, "\n", 1)) return Ok;
    return "error: could not append empty line to TextBuffer";
}

static inline Err
browse_ctx_line_commit(BrowseCtx ctx[static 1]) {
    if (browse_ctx_line_len(ctx)) {
        BufOf(char)* buf = &htmldoc_textbuf(browse_ctx_htmldoc(ctx))->buf;//TODO: use macro not arrow
        BufOf(char)* line = browse_ctx_line(ctx);
        if (!buffn(char, append)(buf, items__(line), len__(line)))
            return "error: could not append empty line to TextBuffer";
        buffn(char, reset)(line);
    }
    return Ok;
}

static inline void
browse_ctx_line_reset(BrowseCtx ctx[static 1]) { buffn(char, reset)(browse_ctx_line(ctx)); }

static inline Err browse_ctx_init(BrowseCtx ctx[static 1], HtmlDoc htmldoc[static 1], bool color) {
    *ctx = (BrowseCtx) {.htmldoc=htmldoc, .color=color, .empty=true};
    return Ok;
}

static inline void browse_ctx_cleanup(BrowseCtx ctx[static 1]) {
    buffn(char, clean)(&ctx->line);
    arlfn(EscCode, clean)(browse_ctx_esc_code_stack(ctx));
}

static inline void
browse_ctx_set_color(BrowseCtx ctx[static 1], bool value) {  ctx->color = value; }


Err serialize_mem_skipping_space(
    const char* data, size_t len, BrowseCtx ctx[static 1]
);

Err browse_rec(lxb_dom_node_t* node, BrowseCtx ctx[static 1]);


static inline Err
browse_list_inline( lxb_dom_node_t* it, lxb_dom_node_t* last, BrowseCtx ctx[static 1]) {
    bool was_empty = browse_ctx_empty_get_set(ctx, true);
    for(; it ; it = it->next) {
        try( browse_rec(it, ctx));
        if (!browse_ctx_empty_get_set(ctx, true)) {
            was_empty = false;
            try( browse_ctx_line_commit(ctx));
        }
        if (it == last) break;
    }
    *browse_ctx_empty(ctx) = was_empty;
    return Ok;
}

static inline Err
browse_list_block( lxb_dom_node_t* it, lxb_dom_node_t* last, BrowseCtx ctx[static 1]) {
    //bool was_empty = browse_ctx_empty_get_set(ctx, false);
    *browse_ctx_empty(ctx) = true;
    size_t inline_childs_count = 0;
    //size_t block_childs_count = 0;

    //try( browse_ctx_line_append_lit__(ctx, "\n"));
    *browse_ctx_pending_line(ctx) = true;
    for(; it ; it = it->next) {
        bool is_block = lexbor_tag_is_block(it);
        try( browse_rec(it, ctx));
        bool empty = browse_ctx_empty_get_set(ctx, true);
        //if (!empty && is_block) browse_ctx_line_reset(ctx);
        if (empty || is_block) continue; //++block_childs_count;
        ++inline_childs_count;

        if ( it == last ) break;
    }

    *browse_ctx_empty(ctx) = inline_childs_count == 0;
    if (!*browse_ctx_empty(ctx)) {
        try( browse_ctx_line_commit(ctx));
        try( _append_empty_line_to_doc_(ctx));
    } else browse_ctx_line_reset(ctx);
    return Ok;
}

static inline Err browse_ctx_line_append_color_(BrowseCtx ctx[static 1], EscCode code) {
    if (browse_ctx_color(ctx)) {
        try( browse_ctx_esc_code_push(ctx, code));
        Str code_str;
        try( esc_code_to_str(code, &code_str));
        try( browse_ctx_line_append(ctx, (char*)code_str.s, code_str.len));
    }
    return Ok;
}
 
static inline Err browse_ctx_line_append_ui_(BrowseCtx ctx[static 1], uintmax_t ui) {
    BufOf(char)* line = browse_ctx_line(ctx);
    return bufofchar_append_ui_as_str(line, ui);
}

static inline Err browse_ctx_line_append_ui_base36_(BrowseCtx ctx[static 1], uintmax_t ui) {
    BufOf(char)* line = browse_ctx_line(ctx);
    return bufofchar_append_ui_base36_as_str(line, ui);
}

static inline Err browse_ctx_reset_color(BrowseCtx ctx[static 1]) {
    if (browse_ctx_color(ctx)) {
        try( browse_ctx_line_append_lit__(ctx, EscCodeReset));
        ArlOf(EscCode)* stack = browse_ctx_esc_code_stack(ctx);
        try( browse_ctx_esc_code_pop(ctx));
        EscCode* backp =  arlfn(EscCode, back)(stack);
        if (backp) {
            Str code_str;
            try( esc_code_to_str(*backp, &code_str));
            try( browse_ctx_line_append(ctx, (char*)code_str.s, code_str.len));
        }
    }
    return Ok;
}

#endif
